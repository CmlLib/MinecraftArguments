import re
import os
import sys

decompilesPath = os.path.abspath("decompiles")
generatedPath = os.path.abspath("generated")

if not os.path.isdir(decompilesPath):
    os.makedirs(decompilesPath)
if not os.path.isdir(generatedPath):
    os.makedirs(generatedPath)

def extractOptionsToMarkdown(name: str):
    source = os.path.join(decompilesPath, name + ".java")
    destination = os.path.join(generatedPath, name + ".md")

    print(f"extracting {source} to {destination}")

    with open(source, 'r') as file:
        content = file.read()

    options = extractOptionsFromJavaCode(content)
    markdown = generateMarkdownDocument(name, options)

    with open(destination, 'w') as file:
        file.write(markdown)

def extractOptionsFromJavaCode(source: str) -> list:
    options = []
    matches = re.findall(r'(accepts.*);', source)

    for specs in matches:
        if not specs:
            continue
        
        option = extractOptionSpec(specs)
        options.append(option)

    return options

def extractOptionSpec(specs: str) -> dict:
    result = {}
    
    state = "methodName"
    methodName = ""
    argument = ""
    bracketLevel = 0

    for char in specs:
        if char == ' ' or char == '\n' or char == '\r':
            pass
        elif char == '(':
            bracketLevel += 1
            if bracketLevel == 1:
                state = "argument"
                continue
        elif char == ')':
            bracketLevel -= 1
            if bracketLevel == 0:
                if not argument:
                    argument = True
                result[methodName] = argument
                state = "methodName"
                methodName = ""
                argument = ""
                continue
        elif char == '.':
            if bracketLevel == 0:
                continue
        
        if state == "methodName":
            methodName += char
        elif state == "argument":
            argument += char

    return result

def generateMarkdownDocument(name: str, options: list) -> str:
    table = optionsToMarkdownTable(options)
    return f'''
# {name}

{table}

generated by arguments_extractor.py
    '''

def optionsToMarkdownTable(options: list) -> str:
    result = ['''
| name | type | default | isRequired | others | description |
|------|------|---------|------------|--------|-------------|
''']

    for opt in options:
        name = opt.get('accepts').strip('"')
        isRequired = opt.get('withRequiredArg') or opt.get('required')
        if not isRequired:
            isRequired = False
        subs = opt.keys() - ["accepts", "ofType", "defaultsTo", "withRequiredArg", "required"]

        result.append(f"| {name} | {opt.get('ofType')} | {opt.get('defaultsTo')} | {isRequired} | {', '.join(subs)} | ~ |\n")

    return ''.join(result)

if __name__ == "__main__":
    if not len(sys.argv) == 2 or not sys.argv[1]:
        print("specify name")
        exit()

    #name = "all"
    name = sys.argv[1]

    if name == "all":
        for filename in os.listdir(decompilesPath):
            if not os.path.isfile(os.path.join(decompilesPath, filename)):
                continue
            extractOptionsToMarkdown(os.path.splitext(filename)[0])
    else:
        extractOptionsToMarkdown(name)

    print("done")
